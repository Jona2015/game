<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>2D Slither.io â€“ Advanced</title>
  <style>
    body { margin: 0; background: #111; overflow: hidden; }
    canvas { display: block; }
    #minimap { position: fixed; right: 10px; top: 10px; width: 180px; height: 180px; background: #000a; border: 2px solid #555; }
    #adminPanel { position: fixed; left: 10px; top: 10px; background: #222a; color: white; padding: 10px; border-radius: 8px; font-family: Arial; }
    #adminPanel input { width: 50px; margin-left: 5px; }
    #adminPanel button { margin-top: 5px; display: block; }
  </style>
</head>
<body>
<div id="adminPanel">
  <label>Admin-Pin: <input type="password" id="adminPin"></label><br>
  <label>Essen spawnen: <input type="number" id="foodAmount" value="100"></label>
  <button onclick="spawnFoodAdmin()">Spawn Food</button>
  <button onclick="admin.killAllBots()">Kill All Bots</button>
  <button onclick="console.log(admin.leaderboard())">Show Leaderboard</button>
</div>

<canvas id="game"></canvas>
<canvas id="minimap"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const mini = document.getElementById('minimap');
const mctx = mini.getContext('2d');

canvas.width = innerWidth;
canvas.height = innerHeight;
mini.width = mini.height = 180;

const WORLD_SIZE = 300000;

// ===== ZOOM =====
let zoom = 0.3;
const MIN_ZOOM = 0.15;
const MAX_ZOOM = 1.2;
const ZOOM_SPEED = 0.1;

window.addEventListener('wheel', e => {
  e.preventDefault();
  zoom -= e.deltaY * ZOOM_SPEED;
  zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));
}, { passive: false });

// =================

let keys = { w:false, a:false, s:false, d:false };

window.addEventListener('keydown', e => {
  if(e.code==='KeyW') keys.w=true;
  if(e.code==='KeyA') keys.a=true;
  if(e.code==='KeyS') keys.s=true;
  if(e.code==='KeyD') keys.d=true;
  if(e.code==='Space') player.boost=true;
});
window.addEventListener('keyup', e => {
  if(e.code==='KeyW') keys.w=false;
  if(e.code==='KeyA') keys.a=false;
  if(e.code==='KeyS') keys.s=false;
  if(e.code==='KeyD') keys.d=false;
  if(e.code==='Space') player.boost=false;
});

const rand=(a,b)=>Math.random()*(b-a)+a;
const dist=(a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
let camera={x:0,y:0};

const foods=[];
const MAX_FOOD=200000;
for(let i=0;i<MAX_FOOD;i++) foods.push({x:rand(-WORLD_SIZE,WORLD_SIZE),y:rand(-WORLD_SIZE,WORLD_SIZE)});

const particles=[];
function explode(x,y,color){
  for(let i=0;i<80;i++)
    particles.push({x,y,vx:rand(-3,3),vy:rand(-3,3),life:60,color});
}
function dropFoodFromSnake(snake){
  for(const s of snake.segments)
    foods.push({x:s.x+rand(-5,5),y:s.y+rand(-5,5)});
}

class Snake{
  constructor(x,y,color,isBot=false){
    this.segments=[{x,y}];
    this.len=12;
    this.speed=5;
    this.boost=false;
    this.angle=0;
    this.color=color;
    this.isBot=isBot;
    this.dead=false;
  }
  update(target){
    if(this.dead) return;
    if(this.boost && this.len>3) this.len-=0.25;
    if(target)
      this.angle=Math.atan2(
        target.y-this.segments[0].y,
        target.x-this.segments[0].x
      );
    const head=this.segments[0];
    const sp=this.boost?this.speed*2.2:this.speed;
    const nh={
      x:head.x+Math.cos(this.angle)*sp,
      y:head.y+Math.sin(this.angle)*sp
    };
    this.segments.unshift(nh);
    while(this.segments.length>this.len) this.segments.pop();
  }
  draw(){
    ctx.fillStyle=this.color;
    for(const s of this.segments){
      ctx.beginPath();
      ctx.arc(s.x,s.y,6,0,Math.PI*2);
      ctx.fill();
    }
  }
}

const player=new Snake(0,0,'lime');
let respawnTimer=0;

const bots=[];
for(let i=0;i<30;i++)
  bots.push(new Snake(rand(-1000,1000),rand(-1000,1000),'red',true));

let score=0;
let leaderboard=[];

function updateScore(){
  score=Math.floor(player.len);
  leaderboard=[{name:'You',score}];
}
function drawLeaderboard(){
  ctx.fillStyle='white';
  ctx.font='18px Arial';
  ctx.fillText('Leaderboard:',canvas.width-160,20);
  leaderboard.forEach((l,i)=>
    ctx.fillText(`${i+1}. ${l.name}: ${l.score}`,canvas.width-160,40+i*20)
  );
}

function spawnFood(amount){
  for(let i=0;i<amount;i++)
    foods.push({x:rand(-WORLD_SIZE,WORLD_SIZE),y:rand(-WORLD_SIZE,WORLD_SIZE)});
}

window.admin={
  spawnFood,
  killAllBots(){
    bots.forEach(b=>{
      if(!b.dead){
        explode(b.segments[0].x,b.segments[0].y,'red');
        dropFoodFromSnake(b);
        b.dead=true;
        setTimeout(()=>{
          b.segments=[{x:rand(-WORLD_SIZE,WORLD_SIZE),y:rand(-WORLD_SIZE,WORLD_SIZE)}];
          b.len=120;
          b.dead=false;
        },1000);
      }
    });
  },
  leaderboard:()=>leaderboard
};

function spawnFoodAdmin(){
  if(document.getElementById('adminPin').value!=='1234'){
    alert('Falscher Admin-Pin!');
    return;
  }
  spawnFood(+document.getElementById('foodAmount').value);
}

function loop(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  camera.x=player.segments[0].x;
  camera.y=player.segments[0].y;

  ctx.translate(canvas.width/2,canvas.height/2);
  ctx.scale(zoom,zoom);
  ctx.translate(-camera.x,-camera.y);

  ctx.fillStyle='orange';
  for(const f of foods){
    ctx.beginPath();
    ctx.arc(f.x,f.y,4,0,Math.PI*2);
    ctx.fill();
    if(!player.dead && dist(player.segments[0],f)<10){
      player.len+=2;
      foods.splice(foods.indexOf(f),1);
    }
  }

  let moveX=0,moveY=0;
  if(keys.w) moveY--;
  if(keys.s) moveY++;
  if(keys.a) moveX--;
  if(keys.d) moveX++;
  let target = moveX||moveY
    ? {x:player.segments[0].x+moveX*100,y:player.segments[0].y+moveY*100}
    : null;

  if(!player.dead) player.update(target);

  bots.forEach(b=>{
    if(!b.dead) b.update(player.segments[0]);
  });

  if(!player.dead) player.draw();
  bots.forEach(b=>!b.dead && b.draw());

  updateScore();
  drawLeaderboard();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
