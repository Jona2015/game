const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 3000 });

let players = {};
const WORLD_SIZE = 3000;
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

// Bots
let bots = [];
for(let i=0;i<5;i++){
  bots.push({ x:Math.random()*2*WORLD_SIZE-WORLD_SIZE, y:Math.random()*2*WORLD_SIZE-WORLD_SIZE, segments:[{x:0,y:0}], len:20, dead:false });
}

// Update Bots
function updateBots(){
  bots.forEach(b=>{
    if(b.dead) return;
    let angle = Math.random()*Math.PI*2;
    b.segments.unshift({x:b.x+Math.cos(angle)*2.5, y:b.y+Math.sin(angle)*2.5});
    b.x = b.segments[0].x;
    b.y = b.segments[0].y;
    while(b.segments.length>b.len) b.segments.pop();
    // Rand check
    if(Math.abs(b.x)>WORLD_SIZE || Math.abs(b.y)>WORLD_SIZE){
      b.dead=true;
      setTimeout(()=>{
        b.x = Math.random()*2*WORLD_SIZE-WORLD_SIZE;
        b.y = Math.random()*2*WORLD_SIZE-WORLD_SIZE;
        b.segments=[{x:b.x,y:b.y}];
        b.len=20;
        b.dead=false;
      },1000);
    }
  });
}

// Main loop for bots
setInterval(()=>{
  updateBots();
  // Collision with players
  for(const pid in players){
    const p = players[pid];
    if(p.dead) continue;
    bots.forEach(b=>{
      if(b.dead) return;
      for(let i=5;i<b.segments.length;i++){
        if(dist(p.segments[0],b.segments[i])<6){
          p.dead=true;
          setTimeout(()=>{
            players[pid] = { x:0,y:0,segments:[{x:0,y:0}], len:20, dead:false };
          },1000);
        }
      }
    });
  }
},50);

wss.on('connection', ws=>{
  const id = Date.now()+Math.random();
  players[id]={x:0,y:0,segments:[{x:0,y:0}], len:20, dead:false};
  ws.send(JSON.stringify({ type:'init', id }));

  ws.on('message', msg=>{
    try{
      const data = JSON.parse(msg);
      if(data.type==='update' && !players[id].dead){
        players[id].x = data.x;
        players[id].y = data.y;
        players[id].len = data.len;
        players[id].segments = data.segments;
        players[id].dead = data.dead;
      }
    }catch(e){}
    // Collision player vs player
    for(const pid in players){
      const p = players[pid];
      if(p.dead) continue;
      for(const oid in players){
        if(pid===oid) continue;
        const o = players[oid];
        if(o.dead) continue;
        for(let i=5;i<o.segments.length;i++){
          if(dist(p.segments[0], o.segments[i])<6){
            p.dead=true;
            setTimeout(()=>{
              players[pid]={x:0,y:0,segments:[{x:0,y:0}], len:20, dead:false};
            },1000);
          }
        }
      }
    }

    // Broadcast
    const snapshot = JSON.stringify({ type:'players', players, bots });
    wss.clients.forEach(client=>{
      if(client.readyState===WebSocket.OPEN) client.send(snapshot);
    });
  });

  ws.on('close', ()=>{
    delete players[id];
    const snapshot = JSON.stringify({ type:'players', players, bots });
    wss.clients.forEach(client=>{
      if(client.readyState===WebSocket.OPEN) client.send(snapshot);
    });
  });
});

console.log("Server l√§uft auf ws://localhost:3000 mit Bots und Kollisionen");
