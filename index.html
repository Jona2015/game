<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>2D Slither.io â€“ Advanced</title>
  <style>
    body { margin: 0; background: #111; overflow: hidden; }
    canvas { display: block; }
    #minimap{
      position:fixed;right:10px;top:10px;
      width:180px;height:180px;
      background:#000a;border:2px solid #555;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<canvas id="minimap"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const mini = document.getElementById('minimap');
const mctx = mini.getContext('2d');
canvas.width = innerWidth;
canvas.height = innerHeight;
mini.width = mini.height = 180;

/* ================== WORLD ================== */
const WORLD_SIZE = 1000;
let zoom = 1.2;

/* ================== INPUT ================== */
let keys = { w:false, a:false, s:false, d:false };
window.addEventListener('keydown', e => {
  if(e.code==='KeyW') keys.w=true;
  if(e.code==='KeyA') keys.a=true;
  if(e.code==='KeyS') keys.s=true;
  if(e.code==='KeyD') keys.d=true;
  if(e.code==='Space') player.boost=true;
});
window.addEventListener('keyup', e => {
  if(e.code==='KeyW') keys.w=false;
  if(e.code==='KeyA') keys.a=false;
  if(e.code==='KeyS') keys.s=false;
  if(e.code==='KeyD') keys.d=false;
  if(e.code==='Space') player.boost=false;
});

/* ================== HELPERS ================== */
const rand = (a,b)=>Math.random()*(b-a)+a;
const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

/* ================== CAMERA ================== */
let camera = { x: 0, y: 0 };

/* ================== FOOD ================== */
const foods = [];
for(let i=0;i<600;i++) foods.push({x:rand(-WORLD_SIZE,WORLD_SIZE),y:rand(-WORLD_SIZE,WORLD_SIZE)});

/* ================== PARTICLES ================== */
const particles=[];
function explode(x,y,color){
  for(let i=0;i<80;i++){
    particles.push({x,y,vx:rand(-3,3),vy:rand(-3,3),life:60,color});
  }
}
function dropFoodFromSnake(snake){
  for(const s of snake.segments){
    foods.push({x:s.x+rand(-5,5),y:s.y+rand(-5,5)});
  }
}

/* ================== SNAKE ================== */
class Snake{
  constructor(x,y,color,isBot=false){
    this.segments=[{x,y}];
    this.len=120;
    this.speed=2.4;
    this.boost=false;
    this.angle=0;
    this.color=color;
    this.isBot=isBot;
    this.dead=false;
  }
  update(target){
    if(this.dead) return;
    if(this.boost && this.len>30){ this.len-=0.25; }
    if(target){ this.angle=Math.atan2(target.y-this.segments[0].y,target.x-this.segments[0].x); }
    const head=this.segments[0];
    const sp=this.boost?this.speed*2.2:this.speed;
    const nh={x:head.x+Math.cos(this.angle)*sp,y:head.y+Math.sin(this.angle)*sp};
    this.segments.unshift(nh);
    while(this.segments.length>this.len) this.segments.pop();
  }
  draw(){
    ctx.fillStyle=this.color;
    for(const s of this.segments){
      ctx.beginPath();ctx.arc(s.x,s.y,6,0,Math.PI*2);ctx.fill();
    }
  }
}

/* ================== PLAYER ================== */
const player=new Snake(0,0,'lime');
let respawnTimer = 0;

/* ================== BOTS ================== */
const bots=[];
for(let i=0;i<10;i++) bots.push(new Snake(rand(-1000,1000),rand(-1000,1000),'red',true));

/* ================== GAME LOOP ================== */
function loop(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  camera.x=player.segments[0].x;
  camera.y=player.segments[0].y;

  ctx.translate(canvas.width/2,canvas.height/2);
  ctx.scale(zoom,zoom);
  ctx.translate(-camera.x,-camera.y);

  ctx.fillStyle='orange';
  for(const f of foods){
    ctx.beginPath();ctx.arc(f.x,f.y,4,0,Math.PI*2);ctx.fill();
    if(!player.dead && dist(player.segments[0],f)<10){ player.len+=2; }
  }

  let moveX=0, moveY=0;
  if(keys.w) moveY-=1;
  if(keys.s) moveY+=1;
  if(keys.a) moveX-=1;
  if(keys.d) moveX+=1;
  let target=null;
  if(moveX||moveY){ target={x:player.segments[0].x+moveX*100,y:player.segments[0].y+moveY*100}; }

  if(!player.dead){ player.update(target); }
  else if(respawnTimer>0){
    respawnTimer--;
    if(respawnTimer===0){
      player.segments=[{x:rand(-WORLD_SIZE,WORLD_SIZE),y:rand(-WORLD_SIZE,WORLD_SIZE)}];
      player.len=120;
      player.dead=false;
    }
  }

  for(const b of bots){
    if(b.dead) continue;
    let tgt=player.segments[0];
    if(dist(b.segments[0],tgt)>800) tgt=foods[Math.floor(Math.random()*foods.length)];
    b.update(tgt);
  }

  for(const b of bots){
    if(b.dead) continue;
    for(let i=20;i<player.segments.length;i++){
      if(dist(b.segments[0],player.segments[i])<6){
        b.dead=true;
        explode(b.segments[0].x,b.segments[0].y,'red');
        dropFoodFromSnake(b);
      }
    }
    for(let i=10;i<b.segments.length;i++){
      if(!player.dead && dist(player.segments[0],b.segments[i])<6){
        explode(player.segments[0].x,player.segments[0].y,'lime');
        dropFoodFromSnake(player);
        player.dead=true;
        respawnTimer=120;
      }
    }
  }

  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx;p.y+=p.vy;p.life--;
    ctx.fillStyle=p.color;
    ctx.fillRect(p.x,p.y,2,2);
    if(p.life<=0) particles.splice(i,1);
  }

  if(!player.dead) player.draw();
  bots.forEach(b=>!b.dead && b.draw());

  drawMiniMap();
  requestAnimationFrame(loop);
}

function drawMiniMap(){
  mctx.clearRect(0,0,mini.width,mini.height);
  const scale=mini.width/(WORLD_SIZE*2);
  const dot=(x,y,c)=>{mctx.fillStyle=c;mctx.fillRect(mini.width/2+x*scale,mini.height/2+y*scale,3,3);};
  if(!player.dead) dot(player.segments[0].x,player.segments[0].y,'lime');
  bots.forEach(b=>!b.dead && dot(b.segments[0].x,b.segments[0].y,'red'));
}

loop();
</script>
</body>
</html>
